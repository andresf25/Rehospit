---
title: "<center><br>Modelo Predicción de Rehospitalizaciones</br>"
Date: "<center>Marzo de 2018</center>"
output: html_notebook
---

<br><div style="text-align: justify">
El objetivo es desarrollar e implementar un modelo de predicción de rehospitalizaciones para apoyar los programas de evitabilidad post-hospitalaria. El análisis se realizará con información que describe las características sociodemográficas del individuo y con algunos datos recolectados por el personal hospitalario para un periodo de tiempo de dos años y medio, que va desde 2016 hasta 2018 </br>

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
rm(list = ls())
options(scipen=10)
source("functions_plot.R")
list.of.packages <- c("readxl", "dplyr", "ggplot2", "ggcorrplot", "VIM", "RColorBrewer", "Information", "knitr", "kableExtra", "gridExtra", "skimr", "nortest", "GGally")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

load <- lapply(list.of.packages, library, character.only = TRUE)
```

<h3>Entendimiento de los Datos</h3>

El archivo contiene registros que corresponden a eventos de rehospitalizaciones y se encuentra detallado a nivel de cada evento hospitalario. En total son 34898 registros, 18 variables, descartando de manera inicial, aquellos atributos que se derivan después del segundo diagnóstico; los datos se describen a continuación:

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
data_rehosp <- read_xlsx("DATA_REHOSP.xlsx",na = c("na", "NA", "null", "NULL"))
data_rehosp %>%
  select(Edad_Hospitalizacion,
         Estrato_Vivienda,
         Rango_Ingresos_Desc,
         Estado_Civil,
         Genero,
         cantidad_marcas,
         Ramo_Id,
         Ciudad_Contacto_Nombre,
         Codigo_Diagnostico_Op,
         Categoria_Dx_Id,
         Quirurgico,
         Fecha_Ingreso_Hosp,
         Numero_Dias_Hospitalario,
         Numero_Dias_Uci,
         Numero_Dias_Uce,
         Proveedor,
         Valor_Pagado_Diagnostico,
         rehosp_cat_oms) %>%
  rename(edad = Edad_Hospitalizacion, 
         estrato = Estrato_Vivienda,
         ingreso = Rango_Ingresos_Desc,
         est_civil = Estado_Civil,
         genero = Genero,
         marcas = cantidad_marcas,
         ramo = Ramo_Id,
         ciudad = Ciudad_Contacto_Nombre,
         diagnos = Codigo_Diagnostico_Op,
         categoria = Categoria_Dx_Id,
         quirur = Quirurgico,
         fecha_ingreso = Fecha_Ingreso_Hosp,
         dias_hosp = Numero_Dias_Hospitalario,
         dias_uci = Numero_Dias_Uci,
         dias_uce = Numero_Dias_Uce,
         proveedor = Proveedor,
         pago_hosp = Valor_Pagado_Diagnostico,
         rehosp_oms = rehosp_cat_oms) -> data_rehosp
head(data_rehosp)
```

Variables continuas (4):

* <b>dias_hosp:</b> días de hospitalización
* <b>dias_uci:</b> número días en UCI
* <b>dias_uce:</b> número días en UCE
* <b>pago_hosp:</b> valor pagado primera hospitalización

Variables nominales (5):

* <b>estrato:</b> estrato Vivienda (0,1,2,3,4,5,6,-1)
* <b>est_civil:</b> estado civil (C,D,S,U,V,-1)
* <b>ciudad:</b> ciudad de contacto del asegurado
* <b>diagnos:</b> código diagnóstico de la primera atención -cie10 
* <b>categoria:</b> categoría del diagnóstico según el tipo de enfermedad

Variable dicotómica (4):

* <b>genero:</b> género del asegurado (M,F)
* <b>ramo:</b> ramo al que pertenece el asegurado
* <b>quirur:</b> Si tuvo algun tipo de servicio relacionado a procedimiento quirúrgico
* <b>rehosp_cat_oms: similitud categoría cie10. Esta es nuestra variable objetivo</b>

Variables discretas (2):

* <b>edad:</b> edad del asegurado en el momento de la hospitalización
* <b>marcas:</b> cantidad de marcas confirmadas del asegurado

Variables ordinales (1):

<b>ingreso:</b> Rango de ingresos

Fecha (1):

<b>Fecha_Ingreso:</b> fecha ingreso hospitalización 

Generamos la estadística descriptiva de los datos; en ella se puede visualizar que es necesario realizar más adelante algunas conversiones en los tipos de datos que vienen por defecto (por ejemplo el estrato aparece como una variable numérica). Pero antes de continuar con la codificación, procederemos a realizar un breve análisis de valores pérdidos que nos permitan refinar la limpieza requerida en los datos.

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
skim_with(numeric = list(hist = NULL))

data_rehosp %>% 
  group_by() %>%
  skim()
```

<br><h4>Análisis de Registros Pérdidos</h4>

En la gráfica siguiente podemos observar que hay en total 3 variables que no contienen registros vacios: estrato, estado civil e ingreso.

A nivel individual el porcentaje de valores perdidos para todos los casos es superior al 25%. De forma combinada hay 318 registros vacíos en ingreso, 259 en sólo el estrato y 144 en el estado civil, el resto  de los campos nulos corresponde a combinaciones entre dos variables; por ende no podemos decir que la probabilidad de que falte un valor depende solo del valor observado, y usar un método para imputarlo (la forma no es aleatoria).

```{r, message = FALSE, warning = FALSE, eval =TRUE, echo = FALSE}

aggr(data_rehosp, 
     combined = FALSE, 
     numbers = TRUE, 
     prop = c(TRUE, FALSE),
     col = c("#CCE5FF", "#0066CC"),
     cex.axis = 0.7,
     border = NA,
     ylab = c("Proporción de Datos Perdidos", "Combinaciones"))
```

Para corroborar que los datos no faltan al azar, se realiza un grafico de correlación que nos ayude a verificar lo anterior. Para ello, construimos un dataframe que indique si el campo está vacio (1) o no (0); con esta información seleccionamos sólo aquellas columnas que tienen algunos (no todos) sus registros nulos y finalmente creamos la matrix de correlación.

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
matrix_miss <- as.data.frame(abs(is.na(data_rehosp)))
only_miss <- matrix_miss[,sapply(matrix_miss, sd) > 0]
corr_miss <- round(cor(only_miss),3)
p.mat <- cor_pmat(only_miss)

ggcorrplot(corr_miss, 
           type = "lower",
           outline.col = "white",
           p.mat = p.mat,
           sig.level = 0.05,
           ggtheme = ggplot2::theme_minimal,
           lab = TRUE,
           colors = c("#99CCFF", "white", "#0066CC")) + 
  labs(title = "Correlacion entre datos perdidos por columna")
```

Dado que con la anterior matrix a un nivel de significancia del 5% se comprueba la hipótesis inicial de no aleatoriedad, se procede a construir una tercera categoría para cada una de las variables que posee campos vacíos.

<br><h4>Visualizando Asociaciones en los datos</h4>

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
ggplot(
  data_rehosp,
  aes(x = dias_hosp,
      y = pago_hosp)) + 
  geom_point(aes(color = as.factor(rehosp_oms))) + 
  labs(title = "Pago vs Días Hospitalizado",
       x = "Total Días", 
       y = "Pago") +
  theme_light() +
  scale_colour_manual(values = c("#99CCFF", "#0066CC"))  +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none") -> p1

ggplot(
  data_rehosp,
  aes(x = dias_uce,
      y = dias_uci,
      color = as.factor(rehosp_oms))) + 
  geom_point() + 
  labs(title = "Días Internado en UCE vs UCI",
       x = "Días UCE", 
       y = "Días UCI",
       fill = "Rehospitalización") +
  theme_light() +
  scale_colour_manual(values = c("#99CCFF", "#0066CC"))  +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none") -> p2

ggplot(
  data_rehosp,
  aes(x = dias_uci,
      y = pago_hosp,
      color = as.factor(rehosp_oms))) + 
  geom_point() + 
  labs(title = "Pago vs Días UCI",
       x = "Días UCI", 
       y = "Pago",
       fill = "Rehospitalización") +
  theme_light() +
  scale_colour_manual(values = c("#99CCFF", "#0066CC"))  +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none") -> p3

ggplot(
  data_rehosp,
  aes(x = dias_uce,
      y = pago_hosp,
      color = as.factor(rehosp_oms))) + 
  geom_point() + 
  labs(title = "Pago vs Días UCI",
       x = "Días UCE", 
       y = "pago",
       fill = "Rehospitalización") +
  theme_light() +
  scale_colour_manual(values = c("#99CCFF", "#0066CC"))  +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none") -> p4

grid.arrange(p1, p2, p3, p4, nrow =2, ncol = 2 )
```

Para estimar si existe una asociación entre las variables que pueda derivarse en colinealidad, se procede primero a verificar que las variables no poseen una distribución normal, una vez realizado esto, se elige el test de Spearman para hallar la correlación lineal por atributo.

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
data_rehosp %>%
  select(pago_hosp, 
         dias_uci,
         dias_uce,
         dias_hosp,
         rehosp_oms) -> data_num

norm_test <- lapply(data_num, lillie.test)
lres <- sapply(norm_test, `[`, c("statistic","p.value"))
t(lres)
```

Los resultados confirman que ninguna de las variables pesenta una distribución normal y las correlaciones relacionadas a continuación, verifican posibles asociaciones entre las variables de los días en que el paciente estuvo internado en la Unidad de Cuidados Intensivos, en la Unidad de Cuidados Especiales y los días que el paciente estuvo hospitalizado. Por conocimiento de facto, la relación entre la variable "dias_uci" y "dias_uce" es entendible, ya que cuando un paciente que ha pasado por la Unidad de Cuidados Intensivos pasó su momento de crisis y su estado de salud es más estable, suele ser remitido a la Unidad de Cuidados Especiales. 

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
corr_num <- round(cor(data_num),4)
p.mat <- cor_pmat(data_num, method = "spearman")

ggcorrplot(corr_num, 
           type = "lower",
           outline.col = "white",
           p.mat = p.mat,
           sig.level = 0.05,
           ggtheme = ggplot2::theme_minimal,
           lab = TRUE,
           colors = c("#99CCFF", "white", "#0066CC")) + 
  labs(title = "Correlacion entre variables numéricas")
```

Las correlaciones obtenidas no cumplen un umbral suficiente para considerarlas importantes, por ende se procede a conservarlas y evaluar más adelante si es preciso eliminarlas definitivamente al construir un modelo con fines predictivos. Por otro lado, la variable categoría y diagnóstico están altamente correlacionadas con la variable endógena, por lo que es necesario eliminarlas del análisis, para no incurrir en posibles sobreajustes en la etapa de modelado.

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
data_rehosp %>%
  mutate(estrato = ifelse(is.na(estrato) | estrato == -1 | estrato == 0, "Sin Informacion", estrato),
         est_civil = ifelse(is.na(est_civil), "Sin Informacion", est_civil),
         ingreso = ifelse(is.na(ingreso), "Sin Informacion", ingreso),
         quirur = ifelse(quirur == 1, 'Si', 'No'),
         edad = case_when( edad <= 30 ~ "18-30",
                           edad >= 31 & edad <= 40 ~ "31-40",
                           edad >= 41 & edad <= 50 ~ "41-50",
                           edad >= 51 & edad <= 60 ~ "51-60",
                           edad >= 61 & edad <= 70 ~ "61-70",
                           edad >= 71 & edad <= 80 ~ "71-80",
                           edad >= 81 ~ "81+"),
         marcas = cut(marcas, breaks = (0:3)*2, include.lowest = TRUE),
         est_civil = as.factor(est_civil),
         ingreso = as.factor(ingreso),
         genero = as.factor(genero),
         ciudad = as.factor(ciudad),
         quirur = as.factor(quirur),
         proveedor = as.factor(proveedor),
         ramo = as.factor(ramo),
         edad = as.factor(edad),
         estrato = as.factor(estrato)) %>%
  select(-diagnos, -categoria, -fecha_ingreso) -> data_rehosp

str(data_rehosp)
```

<h3>Análisis Exploratorio</h3>

<br><h4>Análisis univariado - variables continuas</h4>

Se puede observar que tanto en el numéro de marcas como en la variable de pago, correspondiente al primer diagnóstico, no parece haber una diferencia significativa en la distribución al discriminar por la variable objetivo binaria, es decir, entre los casos de rehospitalización (1) y casos de no rehospitalización (0). Adicionalmente, la distibución en ambas variables no es simétrica. En el caso de las marcas se observa una asimetría positiva o sesgada a la derecha y de manera similar, aunque menos marcada, para el caso del pago en el primer diagnóstico.

Los datos se encuentran bastante dispersos y reflejan presencia de outliers.

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}

p5 <- myboxplot(mydata = data_rehosp, 
                myexposure = "rehosp_oms", 
                myoutcome = "pago_hosp", 
                mytitle = "Pago hospitalización", 
                mylabel_x = "", 
                mylabel_y = "Pago Diag", 
                my_fill = "")

p6 <- myboxplot(mydata = data_rehosp, 
                myexposure = "rehosp_oms", 
                myoutcome = "dias_hosp", 
                mytitle = "Total dias hospitalizado", 
                mylabel_x = "", 
                mylabel_y = "Dias hospitalización", 
                my_fill = "")

p7 <- myboxplot(mydata = data_rehosp, 
                myexposure = "rehosp_oms", 
                myoutcome = "dias_uci", 
                mytitle =  "Total días UCI", 
                mylabel_x = "", 
                mylabel_y = "Dias UCI", 
                my_fill = "")

p8 <- myboxplot(mydata = data_rehosp, 
                myexposure = "rehosp_oms", 
                myoutcome = "dias_uce", 
                mytitle = "Total días UCE", 
                mylabel_x = "", 
                mylabel_y = "Dias UCE", 
                my_fill = "")

grid.arrange(p5, p6, p7, p8,
             nrow = 2,
             ncol = 2)
```

Es evidente la existencia también, de valores atípicos muy marcados tanto en el numéro de días de hospitalización, como en los números de días que el paciente estuvo en la Unidad de Cuidado Intensivo y Especial, en dónde los valores atípicos más grandes suceden en los eventos que terminaron en rehospitalización.

Con el análisis anterior no sólo se logra identificar variables con presencia de valores atípicos, sino que también es posible evidenciar que los datos se encuentran altamente desbalanceados. Por ende, antes de continur con la exploración de los datos se procede a tratar ambos problemas. En el caso de los outliers se truncará en los casos en que sea necesario, imputando los valores que superen cierto límite en el percntil, tanto mayor como menor.

```{r}
data_rehosp %>%
  mutate(pago_hosp = outlier(mydata = ., 
                             value = "pago_hosp", 
                             q_min = 0.05, q_max = 0.95),
         dias_hosp = outlier(mydata = ., 
                             value = "dias_hosp",
                             q_min = 0.05, q_max = 0.95),
         dias_uci = outlier(mydata = ., 
                            value = "dias_uci", 
                            q_min = 0.01, q_max = 0.99),
         dias_uce = outlier(mydata = ., 
                            value = "dias_uce", 
                            q_min = 0.01, q_max = 0.99)) -> data_rehosp

filter(data_rehosp, dias_uci > 0) -> z

z$dias_uci = outlier(z, "dias_uci", 0.05,0.95)

quantile(z$dias_uci, 
         c(0.01,0.99), 
         na.rm = TRUE)

```


<br><h4>Análisis univariado - variables cardinales</h4>

Observando las variables categóricas la diferencia entre la probabilidad de que el evento ocurra (haya rehospitalización) o no, se puede evidenciar sólo en algunas clases por categoría, pero en general, las proporciones suelen ser bastantes similares, por lo que no es posible elaborar a priori una hipótesis que estipule diferencias significativas en las distribuciones, por lo menos para ninguna de las tres variables relacionadas en el gráfico a continuación.


```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}

p9 <- mygeom_bar(mydata = data_rehosp, 
                 myexposure = "edad", 
                 myoutcome = "rehosp_oms", 
                 mytitle = "Edad", 
                 mylabel_x = "", 
                 mylabel_y = "Frecuencia", 
                 my_fill = "Rehospitalización", 
                 my_angle = NULL,
                 my_legend = "none")

p10 <- mygeom_bar(mydata = data_rehosp, 
                  myexposure = "estrato", 
                  myoutcome = "rehosp_oms", 
                  mytitle = "Estrato", 
                  mylabel_x = "", 
                  mylabel_y = "Frecuencia", 
                  my_fill = "Rehospitalización", 
                  my_angle = NULL,
                  my_legend = "right")

grid.arrange(p9,                                    
             p10)
```

Por otro lado, los atributos que indican: el rango de ingreso y el hecho de que se hayan realizado procedimientos quirúrgicos durante la primera hospitalización muestran cierta diferencia en la distribuión por grupo. Por ejemplo, cuando se realizan cirugías derivadas del primer diagnóstico, es más probable que la persona deba ser rehospitalizada de nuevo.

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}

p12 <- mygeom_bar(mydata = data_rehosp, 
                  myexposure = "ingreso", 
                  myoutcome = "rehosp_oms", 
                  mytitle = "Ingreso", 
                  mylabel_x = "", 
                  mylabel_y = "Frecuencia",
                  my_fill = "Rehospitalización", 
                  my_angle = 90,
                  my_legend = "none")

p14 <- mygeom_bar(mydata = data_rehosp, 
                  myexposure = "quirur", 
                  myoutcome = "rehosp_oms", 
                  mytitle = "Proc quirúrgico", 
                  mylabel_x = "", 
                  mylabel_y = "Frecuencia", 
                  my_fill = "Rehospitalización", 
                  my_angle = NULL,
                  my_legend = "bottom")

grid.arrange(p12,
             p14,
            ncol = 2,
            nrow = 1)
```

```{r, warning = FALSE, message = FALSE, echo = FALSE, eval = FALSE}

p15 <- mygeom_bar(mydata = data_rehosp, 
                  myexposure = "ramo", 
                  myoutcome = "rehosp_oms", 
                  mytitle = "Ramo Seguro", 
                  mylabel_x = "", 
                  mylabel_y = "Frecuencia", 
                  my_fill = "Rehospitalización", 
                  my_angle = NULL,
                  my_legend = "none")

p16 <- mygeom_bar(mydata = data_rehosp, 
                  myexposure = "est_civil", 
                  myoutcome = "rehosp_oms", 
                  mytitle = "Estado civil", 
                  mylabel_x = "", 
                  mylabel_y = "Frecuencia", 
                  my_fill = "Rehospitalización", 
                  my_angle = NULL,
                  my_legend = "right")


p11 <- mygeom_bar(mydata = data_rehosp, 
                  myexposure = "genero", 
                  myoutcome = "rehosp_oms", 
                  mytitle = "Género", 
                  mylabel_x = "", 
                  mylabel_y = "Frecuencia", 
                  my_fill = "Rehospitalización", 
                  my_angle = NULL,
                  my_legend = "none")


grid.arrange(p15,
             p11,
             p16,
            ncol = 2,
            nrow = 2,
            layout_matrix = rbind(c(1,2), c(3,3)))

```

Con el análisis anterior no sólo se logra identificar variables con presencia de valores atípics, sino que también es posible evidenciar que los datos se encuentran altamente desbalanceados. Por ende, antes de continur con la exploración de los datos se procede a tratar ambos problemas. En el caso de los outliers se truncará en los casos en que sea necesario, imputando los valores que superen cierto límite en el percntil, tanto mayor como menor.

Con el objetivo de enriquecer el análisis exploratorio, se calcularán dos medidas muy comúnes de la teoría de la información, éstas permiten inferir algo del poder predictivo que pueden tener las variables independientes, antes de hacer parte de un modelo.

<br><h4>Análisis de clasificación binaria usando WOE y el IV</h4>
El peso de la evidencia (WOE) y el valor de la información (IV) ayudan, entre otras cosas, a determinar la contribución independiente de cada variable al resultado, y detectar relaciones lineales y no lineales. El WOE mide la relación entre la variable predictiva y el objeto binario, mientras que el IV mide la fuerza predictiva de esa relación.

La tabla a continuación contiene los valores del "valor de la información" con y sin el ajuste derivado de la validación cruzada. Cuando se realiza el ajuste con el objetivo de que los resultados sean más estables, sólo el pago del diagnóstico, si el paciente pasó por la Unidad de cuidados Especiales la primera vez y si fueron realizados procedimientos quirúrgicos serán las únicas variables con suficiente capacidad de predicción a nivel individual y univariable (Iv > 5%). Cuando se relaja el supuesto, IV sin restar el penalty, se incluirían las marcas y la edad y la ciudad.

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
set.seed(1234)

data_rehosp <- data_rehosp %>%
  mutate(id = 1:nrow(.)) 

data_rehosp %>%
  sample_frac(size = .70) -> train

data_rehosp %>%
  anti_join(x = .,
            y = train, 
            by = "id") -> test
  

train <- select(.data = train, -id)
test <- select(.data = test, -id)

IV <- create_infotables(data = train,
                   valid = test,
                   y = "rehosp_oms")


kable_styling(kable(IV$Summary), 
              position = "center", 
              row_label_position = 1,
              full_width = F)
```

Enfocandonos en el pago del diagnóstico, el cual, es la variable con mayor influencia, el WOE nos indica una relación no lineal. con un incremento en el WOE a medida que disminuye el rango de pago en el diagnóstico. 

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
kable_styling(kable(IV$Tables$pago_hosp1), 
              position = "center", 
              row_label_position = 1,
              full_width = F)
```

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
n <- names(IV$Tables)
for (i in 1:length(n)){
   plot_infotables(IV, n[i])}

MultiPlot(IV, IV$Summary$Variable[1:9])
```

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
MultiPlot(IV, IV$Summary$Variable[10:18])
```
ssss
```{r}
## Loading DMwr to balance the unbalanced class
library(DMwR)

prop.table(table(data_rehosp$rehosp_oms))
table(data_rehosp$rehosp_oms)

data_rehosp2 <- data_rehosp
class(data_rehosp2)
str(data_rehosp2)

data_rehosp2 %>%
  select(-fecha_ingreso) -> data_rehosp2

data_rehosp2$rehosp_oms <- as.factor(data_rehosp2$rehosp_oms)
data_rehosp2$edad <- as.factor(data_rehosp2$edad)
data_rehosp2$estrato <- as.factor(data_rehosp2$estrato)

## Smote : Synthetic Minority Oversampling Technique To Handle Class Imbalancy In Binary Classification
## now using SMOTE to create a more "balanced problem"
newData <- SMOTE(rehosp_oms ~ ., as.data.frame(data_rehosp2), perc.over = 100, perc.under = 200)
#newData <- SMOTE(rehosp_oms ~ ., as.data.frame(data_rehosp2), perc.over = 1400, perc.under = 140)

table(newData$rehosp_oms)
prop.table(table(newData$rehosp_oms))
head(newData)
head(data_rehosp)

newData <- tbl_df(newData)

class(newData)
class(data_rehosp)
```
