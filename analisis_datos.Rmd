---
title: "<center><br>Modelo Predicción de Rehospitalizaciones</br>"
Date: "<center>Marzo de 2018</center>"
output: html_notebook
---

<br><div style="text-align: justify">
El objetivo es desarrollar e implementar un modelo de predicción de rehospitalizaciones para apoyar los programas de evitabilidad post-hospitalaria. El análisis se realizará con información que describe las características sociodemográficas del individuo y con algunos datos recolectados por el personal hospitalario para un periodo de tiempo de dos años y medio, que va desde 2016 hasta 2018 </br>

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
rm(list = ls())
options(scipen=10)
source("functions_plot.R")
list.of.packages <- c("readxl", "dplyr", "ggplot2", "ggcorrplot", "VIM", "RColorBrewer", "Information", "knitr", "kableExtra", "gridExtra", "skimr")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

load <- lapply(list.of.packages, library, character.only = TRUE)
```

<h3>Entendimiento de los Datos</h3>

El archivo contiene registros que corresponden a eventos de rehospitalizaciones y se encuentra detallado a nivel de cada evento hospitalario. En total son 34898 registros, 18 variables, descartando de manera inicial, aquellos atributos que se derivan después del segundo diagnóstico.los datos se describen a continuación:

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
data_rehosp <- read_xlsx("DATA_REHOSP.xlsx",na = c("na", "NA", "null", "NULL"))
data_rehosp %>%
  select(Edad_Hospitalizacion,
         Estrato_Vivienda,
         Rango_Ingresos_Desc,
         Estado_Civil,
         Genero,
         cantidad_marcas,
         Ramo_Id,
         Ciudad_Contacto_Nombre,
         Codigo_Diagnostico_Op,
         Categoria_Dx_Id,
         Quirurgico,
         Fecha_Ingreso_Hosp,
         Numero_Dias_Hospitalario,
         Numero_Dias_Uci,
         Numero_Dias_Uce,
         Proveedor,
         Valor_Pagado_Diagnostico,
         rehosp_cat_oms) %>%
  rename(edad = Edad_Hospitalizacion, 
         estrato = Estrato_Vivienda,
         ingreso = Rango_Ingresos_Desc,
         est_civil = Estado_Civil,
         genero = Genero,
         marcas = cantidad_marcas,
         ramo = Ramo_Id,
         ciudad = Ciudad_Contacto_Nombre,
         diagnos = Codigo_Diagnostico_Op,
         categoria = Categoria_Dx_Id,
         quirur = Quirurgico,
         fecha_ingreso = Fecha_Ingreso_Hosp,
         dias_hosp = Numero_Dias_Hospitalario,
         dias_uci = Numero_Dias_Uci,
         dias_uce = Numero_Dias_Uce,
         proveedor = Proveedor,
         pago_hosp = Valor_Pagado_Diagnostico,
         rehosp_oms = rehosp_cat_oms) -> data_rehosp
head(data_rehosp)
```

Variables continuas (5):

* <b>marcas:</b> Cantidad de marcas confirmadas del asegurado
* <b>dias_hosp:</b> Dias de hospitalización
* <b>dias_uci:</b> Número dias en uci
* <b>dias_uce:</b> Número dias en uce
* <b>pago_hosp:</b> Valor pagado primera hospitalización

Variables nominales (5):

* <b>estrato:</b> Estrato Vivienda (0,1,2,3,4,5,6,-1)
* <b>est_civil:</b> Estado civil (C,D,S,U,V,-1)
* <b>ciudad:</b> Ciudad de contacto del asegurado
* <b>diagnos:</b> Codigo Diagnóstico de la primera atención -cie10 
* <b>categoria:</b> Categoría del diagnóstico según el tipo de enfermedad

Variable dicotómica (4):

* <b>genero:</b> Género del asegurado (M,F)
* <b>ramo:</b> Ramo al que pertenece el asegurado
* <b>quirur:</b> Si tuvo algun tipo de servicio relacionado a procedimiento quirúrgico
* <b>rehosp_cat_oms: Similitud categoría cie10. Esta es nuestra variable objetivo</b>

Variables discretas (1):

<b>edad:</b> Edad del asegurado en el momento de la hospitalización

Variables ordinales (1):

<b>ingreso:</b> Rango de ingresos

Fecha (1):

<b>Fecha_Ingreso:</b> Fecha ingreso hospitalización 

Generamos la estadística descriptiva de los datos; en ella se puede visualizar que es necesario realizar más adelante algunas conversiones en los tipos de datos que vienen por defecto (por ejemplo el estrato aparece como una variable numérica). Pero antes de continuar con la codificación, procederemos a realizar un breve análisis de valores pérdidos que nos permitan refinar la limpieza requerida en los datos.

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
skim_with(numeric = list(hist = NULL))

data_rehosp %>% 
  group_by() %>%
  skim()
```

<br><h4>Análisis de Registros Pérdidos</h4>

En la gráfica siguiente podemos observar que hay en total 3 variables que no contienen registros vacios: estrato, estado civil e ingreso.

A nivel individual el porcentaje de valores perdidos para todos los casos es superior al 25%. De forma combinada hay 318 registros vacíos en ingreso, 259 en sólo el estrato y 144 en el estado civil, el resto  de los campos nulos corresponde a combinaciones entre dos variables; por ende no podemos decir que la probabilidad de que falte un valor depende solo del valor observado, y usar un método para imputarlo (la forma no es aleatoria).

```{r, message = FALSE, warning = FALSE, eval =TRUE, echo = FALSE}

aggr(data_rehosp, 
     combined = FALSE, 
     numbers = TRUE, 
     prop = c(TRUE, FALSE),
     col = c("#CCE5FF", "#0066CC"),
     cex.axis = 0.7,
     border = NA,
     ylab = c("Proporción de Datos Perdidos", "Combinaciones"))
```

Para corroborar que los datos no faltan al azar, se realiza un grafico de correlación que nos ayude a verificar lo anterior. Para ello, construimos un dataframe que indique si el campo está vacio (1) o no (0); con esta información seleccionamos sólo aquellas columnas que tienen algunos (no todos) sus registros nulos y finalmente creamos la matrix de correlación.

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
matrix_miss <- as.data.frame(abs(is.na(data_rehosp)))
only_miss <- matrix_miss[,sapply(matrix_miss, sd) > 0]
corr_miss <- round(cor(only_miss),3)
p.mat <- cor_pmat(only_miss)

ggcorrplot(corr_miss, 
           type = "lower",
           outline.col = "white",
           p.mat = p.mat,
           sig.level = 0.05,
           ggtheme = ggplot2::theme_minimal,
           lab = TRUE,
           colors = c("#99CCFF", "white", "#0066CC")) + 
  labs(title = "Correlacion entre datos perdidos por columna")
```

Dado que con la anterior matrix a un nivel de significancia del 5% se comprueba la hipótesis inicial de no aleatoriedad, se procede a construir una tercera categoría para cada una de las variables que posee campos vacíos.

La variable categoría y diagnóstico están altamente correlacionadas con la variable endógena, se procede a eliminarlas del análisis para no incurrir en posibles sobreajustes en la etapa de modelado.

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
data_rehosp %>%
  mutate(estrato = ifelse(is.na(estrato) | estrato == -1 | estrato == 0, "Sin Informacion", estrato),
         est_civil = ifelse(is.na(est_civil), "Sin Informacion", est_civil),
         ingreso = ifelse(is.na(ingreso), "Sin Informacion", ingreso),
         quirur = ifelse(quirur == 1, 'Si', 'No'),
         edad = case_when( edad <= 30 ~ "18-30",
                           edad >= 31 & edad <= 40 ~ "31-40",
                           edad >= 41 & edad <= 50 ~ "41-50",
                           edad >= 51 & edad <= 60 ~ "51-60",
                           edad >= 61 & edad <= 70 ~ "61-70",
                           edad >= 71 & edad <= 80 ~ "71-80",
                           edad >= 81 ~ "81+"),
         est_civil = as.factor(est_civil),
         ingreso = as.factor(ingreso),
         genero = as.factor(genero),
         ciudad = as.factor(ciudad),
         quirur = as.factor(quirur),
         proveedor = as.factor(proveedor),
         ramo = as.factor(ramo),
         edad = as.factor(edad),
         estrato = as.factor(estrato)) %>%
  select(-diagnos, -categoria) -> data_rehosp

str(data_rehosp)
```

<h3>Análisis Exploratorio</h3>

<br><h4>Análisis univariado - variables continuas</h4>

Se puede observar que tanto en el numéro de marcas como en la variable de pago, correspondiente al primer diagnóstico, no parece haber una diferencia significativa en la distribución al discriminar por la variable objetivo binaria, es decir, entre los casos de rehospitalización (1) y casos de no rehospitalización (0). Adicionalmente, la distibución en ambas variables no es simétrica. En el caso de las marcas se observa una asimetría positiva o sesgada a la derecha y de manera similar, aunque menos marcada, para el caso del pago en el primer diagnóstico.

Los datos se encuentran bastante dispersos y reflejan presencia de outliers.

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}

p1 <- myboxplot(mydata = data_rehosp, 
                myexposure = "rehosp_oms", 
                myoutcome = "marcas", 
                mytitle = "", 
                mylabel_x = "Rehospitalización", 
                mylabel_y = "Marcas", 
                my_fill = "Rehospitalización")

p2 <- myboxplot(mydata = data_rehosp, 
                myexposure = "rehosp_oms", 
                myoutcome = "pago_hosp", 
                mytitle = "", 
                mylabel_x = "Rehospitalización", 
                mylabel_y = "Pago Diag", 
                my_fill = "")

ggplot(
  data_rehosp, 
  aes(x = marcas, 
      color =  as.factor(rehosp_oms), 
      shape = as.factor(rehosp_oms))) + 
  geom_density() +
  labs(title="Total de marcas",
       x = "", 
       y = "Frecuencia") +
  theme_light() + 
  theme(plot.title = element_text(hjust = 0.5),legend.position = "none") +
  scale_colour_manual(values = c("#99CCFF", "#0066CC")) -> p3

ggplot(
  data_rehosp, 
  aes(x = pago_hosp, 
      color =  as.factor(rehosp_oms), 
      shape = as.factor(rehosp_oms))) + 
  geom_histogram(alpha = .2,
                 fill= "white", 
                 position = "identity",
                 size = 0.8) + 
  labs(title = "Pago primer diágnóstico",
       x = "", 
       y = "Frecuencia") +
  theme_light() + 
  theme(plot.title = element_text(hjust = 0.5),legend.position = "none") +
  scale_colour_manual(values = c("#99CCFF", "#0066CC")) -> p4


grid.arrange(p3, p4, p1, p2, nrow = 2, ncol = 2)
```

Es evidente la existencia también, de valores atípicos muy marcados tanto en el numéro de días de hospitalización, como en los números de días que el paciente estuvo en la Unidad de Cuidado Intensivo y Especial, en dónde los valores atípicos más grandes suceden en los eventos que terminaron en rehospitalización.

Cabe anotar, que puede existir una colinealidad entre la vaiable días UCE y UCI que debe ser validada más adelante, ya que los pacientes que pasaron por un momento de crisis en la UCI, suelen ser luego remitidos a la UCE cuando sus signos vitales se encuentran más estables y están en proceso de mejora.


```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}

p5 <- myboxplot(mydata = data_rehosp, 
                myexposure = "rehosp_oms", 
                myoutcome = "dias_hosp", 
                mytitle = "Total dias hospitalizado", 
                mylabel_x = "", 
                mylabel_y = "Dias hospitalización", 
                my_fill = "")

p6 <- myboxplot(mydata = z, 
                myexposure = "rehosp_oms", 
                myoutcome = "dias_uci", 
                mytitle =  "Total días UCI", 
                mylabel_x = "", 
                mylabel_y = "Dias UCI", 
                my_fill = "")

p7 <- myboxplot(mydata = data_rehosp, 
                myexposure = "rehosp_oms", 
                myoutcome = "dias_uce", 
                mytitle = "Total días UCE", 
                mylabel_x = "", 
                mylabel_y = "Dias UCE", 
                my_fill = "")

grid.arrange(p5, p6, p7,
             ncol = 2, 
             nrow = 2)
```

Con el análisis anterior no sólo se logra identificar variables con presencia de valores atípics, sino que también es posible evidenciar que los datos se encuentran altamente desbalanceados. Por ende, antes de continur con la exploración de los datos se procede a tratar ambos problemas. En el caso de los outliers se truncará en los casos en que sea necesario, imputando los valores que superen cierto límite en el percntil, tanto mayor como menor.

```{r}
data_rehosp %>%
  mutate(marcas = outlier(mydata = ., 
                          value = "marcas", 
                          q_min = 0.05, q_max = 0.95),
         pago_hosp = outlier(mydata = ., 
                             value = "pago_hosp", 
                             q_min = 0.05, q_max = 0.95),
         dias_hosp = outlier(mydata = ., 
                             value = "dias_hosp",
                             q_min = 0.05, q_max = 0.95),
         dias_uci = outlier(mydata = ., 
                            value = "dias_uci", 
                            q_min = 0.01, q_max = 0.99),
         dias_uce = outlier(mydata = ., 
                            value = "dias_uce", 
                            q_min = 0.01, q_max = 0.99)) -> data_rehosp

filter(data_rehosp, dias_uci > 0) -> z

z$dias_uci = outlier(z, "dias_uci", 0.05,0.95)

quantile(z$dias_uci, 
         c(0.01,0.99), 
         na.rm = TRUE)

```


<br><h4>Análisis univariado - variables cardinales</h4>

Observando las variables categóricas la diferencia entre la probabilidad de que el evento ocurra (haya rehospitalización) o no, se puede evidenciar sólo en algunas clases por categoría, pero en general, las proporciones suelen ser bastantes similares, por lo que no es posible elaborar a priori una hipótesis que estipule diferencias significativas en las distribuciones, por lo menos para ninguna de las tres variables relacionadas en el gráfico a continuación.


```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}

p9 <- mygeom_bar(mydata = data_rehosp, 
                 myexposure = "edad", 
                 myoutcome = "rehosp_oms", 
                 mytitle = "Edad", 
                 mylabel_x = "", 
                 mylabel_y = "Frecuencia", 
                 my_fill = "Rehospitalización", 
                 my_angle = NULL)

p10 <- mygeom_bar(mydata = data_rehosp, 
                  myexposure = "estrato", 
                  myoutcome = "rehosp_oms", 
                  mytitle = "Estrato", 
                  mylabel_x = "", 
                  mylabel_y = "Frecuencia", 
                  my_fill = "Rehospitalización", 
                  my_angle = NULL)

p11 <- mygeom_bar(mydata = data_rehosp, 
                  myexposure = "genero", 
                  myoutcome = "rehosp_oms", 
                  mytitle = "Género", 
                  mylabel_x = "", 
                  mylabel_y = "Frecuencia", 
                  my_fill = "Rehospitalización", 
                  my_angle = NULL)

grid.arrange(p9,                                    
             p10, p11,                               
             ncol = 2, nrow = 2,
             layout_matrix = rbind(c(1,1), c(2,3)))
```

Por otro lado, los atributos que indican: el rango de ingreso y el hecho de que se hayan realizado procedimientos quirúrgicos durante la primera hospitalización muestran cierta diferencia en la distribuión por grupo. Por ejemplo, cuando se realizan cirugías derivadas del primer diagnóstico, es más probable que la persona deba ser rehospitalizada de nuevo.

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}

p12 <- mygeom_bar(mydata = data_rehosp, 
                  myexposure = "ingreso", 
                  myoutcome = "rehosp_oms", 
                  mytitle = "Ingreso", 
                  mylabel_x = "", 
                  mylabel_y = "Frecuencia",
                  my_fill = "Rehospitalización", 
                  my_angle = 90)

p14 <- mygeom_bar(mydata = data_rehosp, 
                  myexposure = "quirur", 
                  myoutcome = "rehosp_oms", 
                  mytitle = "Proc quirúrgico", 
                  mylabel_x = "", 
                  mylabel_y = "Frecuencia", 
                  my_fill = "Rehospitalización", 
                  my_angle = NULL)
grid.arrange(p12,
             p14,
            ncol = 2  )
```

```{r, warning = FALSE, message = FALSE, echo = FALSE, eval = FALSE}

p15 <- mygeom_bar(mydata = data_rehosp, 
                  myexposure = "ramo", 
                  myoutcome = "rehosp_oms", 
                  mytitle = "Ramo Seguro", 
                  mylabel_x = "", 
                  mylabel_y = "Frecuencia", 
                  my_fill = "Rehospitalización", 
                  my_angle = NULL)

p16 <- mygeom_bar(mydata = data_rehosp, 
                  myexposure = "est_civil", 
                  myoutcome = "rehosp_oms", 
                  mytitle = "Estado civil", 
                  mylabel_x = "", 
                  mylabel_y = "Frecuencia", 
                  my_fill = "Rehospitalización", 
                  my_angle = NULL)

grid.arrange(p15, p16)
```

Con el objetivo de enriquecer el análisis exploratorio, se calcularán dos medidas muy comúnes de la teoría de la información, éstas permiten inferir algo del poder predictivo que pueden tener las variables independientes, antes de hacer parte de un modelo.

<br><h4>Análisis de clasificación binaria usando WOE y el IV</h4>
El peso de la evidencia (WOE) y el valor de la información (IV) ayudan, entre otras cosas, a determinar la contribución independiente de cada variable al resultado, y detectar relaciones lineales y no lineales. El WOE mide la relación entre la variable predictiva y el objeto binario, mientras que el IV mide la fuerza predictiva de esa relación.

La tabla a continuación contiene los valores del "valor de la información" con y sin el ajuste derivado de la validación cruzada. Cuando se realiza el ajuste con el objetivo de que los resultados sean más estables, sólo el pago del diagnóstico, si el paciente pasó por la Unidad de cuidados Especiales la primera vez y si fueron realizados procedimientos quirúrgicos serán las únicas variables con suficiente capacidad de predicción a nivel individual y univariable (Iv > 5%). Cuando se relaja el supuesto, IV sin restar el penalty, se incluirían las marcas y la edad y la ciudad.

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
set.seed(1234)

data_rehosp <- data_rehosp %>%
  mutate(id = 1:nrow(.)) 

data_rehosp %>%
  sample_frac(size = .70) -> train

data_rehosp %>%
  anti_join(x = .,
            y = train, 
            by = "id") -> test
  

train <- select(.data = train, -id)
test <- select(.data = test, -id)

IV <- create_infotables(data = train,
                   valid = test,
                   y = "rehosp_oms")


kable_styling(kable(IV$Summary), 
              position = "center", 
              row_label_position = 1,
              full_width = F)
```

Enfocandonos en el pago del diagnóstico, el cual, es la variable con mayor influencia, el WOE nos indica una relación no lineal. con un incremento en el WOE a medida que disminuye el rango de pago en el diagnóstico. 

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
kable_styling(kable(IV$Tables$pago_hosp1), 
              position = "center", 
              row_label_position = 1,
              full_width = F)
```

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
n <- names(IV$Tables)
for (i in 1:length(n)){
   plot_infotables(IV, n[i])}

MultiPlot(IV, IV$Summary$Variable[1:9])
```

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
MultiPlot(IV, IV$Summary$Variable[10:18])
```
ssss
```{r}
## Loading DMwr to balance the unbalanced class
library(DMwR)

prop.table(table(data_rehosp$rehosp_oms))

table(data_rehosp$rehosp_oms)

str(data_rehosp2)

data_rehosp2 <- data_rehosp
#data_rehosp2$rehosp_oms <- factor(ifelse(data_rehosp2$rehosp_oms == 1,"si","no")) 
data_rehosp2$rehosp_oms <- as.factor(data_rehosp2$rehosp_oms)
data_rehosp2$edad <- as.factor(data_rehosp2$edad) 
data_rehosp2$estrato <- as.factor(data_rehosp2$estrato)
data_rehosp2$ramo <- as.factor(data_rehosp2$ramo) 


data_rehosp2 %>%
  select(-fecha_ingreso) -> data_rehosp2


## Smote : Synthetic Minority Oversampling Technique To Handle Class Imbalancy In Binary Classification
## now using SMOTE to create a more "balanced problem"
newData <- SMOTE(rehosp_oms ~ ., as.data.frame(data_rehosp2), perc.over = 200, perc.under = 100)
newData <- SMOTE(rehosp_oms ~ ., as.data.frame(data_rehosp2), perc.over = 1400, perc.under = 140)

table(newData$rehosp_oms)
prop.table(table(newData$rehosp_oms))
head(newData)
```
