---
title: "<center><br>Modelo Predicción de Rehospitalizaciones</br>"
Date: "<center>Abril/2019</center>"
output: html_notebook
---

<h1 style="text-align: center;"><a id="Inicio"></a>Análisis exploratorio---completar titulo</h1>
<h4 style="text-align: center;">Abril/2019</h4>

<table>
<tr>
<td><img style="width:270px; height:200px;" src="SURA.png" /></td>
<td><img style="width:150px; height:150px;" src="blanco.jpg" /></td>
<td><img style="width:500px; height:100px;" src="Datalytics.png" /></td>
</tr>
</table>


<h2 style="text-align: center;">Índice</h2>
<ol>
    <li><a href="#Generalidades">Generalidades</a></li>
    <li><a href="#Entendimiento">Entendimiento de los datos</a></li>
    <li><a href="#Perdidos">Análisis de Registros Pérdidos</a></li>
    <li><a href="#Analisis">Análisis Exploratorio</a></li>
      <ol>
        <li><a href="#AnalisisCon">Análisis univariado - variables continuas</a></li>
        <li><a href="#AnalisisCar">Análisis univariado - variables cardinales</a></li>
        </ol>
    <li><a href="#AnalisisWOE">Análisis de clasificación binaria usando WOE y el IV</a></li>
    <li><a href="#Modelo">Modelo</a></li>
      <ol>
        <li><a href="#SMOTE">SMOTE - Balanceo de categoria minoritaria</a></li>
        <li><a href="#AnalisisCar">Análisis univariado - variables cardinales</a></li>
      </ol>
    <li><a href="#Relaciones">Relaciones entre variables</a></li>
    <li><a href="#Comparaciones">Comparaciones</a></li>
</ol>
<p style="text-align: justify;">Haciendo click sobre cada una de las secciones puede ir directamente a cada una de ellas. Al finalizar cada sección encontrará un link para volver al índice.</p>

<h2 style="text-align: center;"><a id="Generalidades">Generalidades</a></h2>
<p style="text-align: justify;">El objetivo es desarrollar e implementar un modelo de predicción de rehospitalizaciones para apoyar los programas de evitabilidad post-hospitalaria. El análisis se realizará con información que describe las características sociodemográficas del individuo y con algunos datos recolectados por el personal hospitalario para un periodo de tiempo de dos años y medio, que va desde 2016 hasta 2018.</p>


<a href="#Inicio">Volver al inicio</a></li>

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
rm(list = ls())
set.seed(1234)
options(scipen = 100)

source("functions_plot.R")

list.of.packages <- c("readxl", "dplyr", "ggplot2", "ggcorrplot", "VIM", "RColorBrewer", "Information", "knitr", "kableExtra", "gridExtra", "skimr", "nortest", "GGally", "plotly", "lattice", "DMwR", "caTools", "plotly")

new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

load <- lapply(list.of.packages, library, character.only = TRUE)
```

<h2 style="text-align: center;"><a id="Entendimiento">Entendimiento de los datos</a></h2>

<p style="text-align: justify;">El archivo contiene registros que corresponden a eventos de rehospitalizaciones y se encuentra detallado a nivel de cada evento hospitalario. En total son 34898 registros, 18 variables, descartando de manera inicial, aquellos atributos que se derivan después del segundo diagnóstico; los datos se describen a continuación:</p>

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
data_rehosp <- read_xlsx("DATA_REHOSP.xlsx",na = c("na", "NA", "null", "NULL"))
data_rehosp %>%
  select(Edad_Hospitalizacion,
         Estrato_Vivienda,
         Rango_Ingresos_Desc,
         Estado_Civil,
         Genero,
         cantidad_marcas,
         Ramo_Id,
         Ciudad_Contacto_Nombre,
         Codigo_Diagnostico_Op,
         Categoria_Dx_Id,
         Quirurgico,
         Fecha_Ingreso_Hosp,
         Numero_Dias_Hospitalario,
         Numero_Dias_Uci,
         Numero_Dias_Uce,
         Proveedor,
         Valor_Pagado_Diagnostico,
         rehosp_cat_oms) %>%
  rename(edad = Edad_Hospitalizacion, 
         estrato = Estrato_Vivienda,
         ingreso = Rango_Ingresos_Desc,
         est_civil = Estado_Civil,
         genero = Genero,
         marcas = cantidad_marcas,
         ramo = Ramo_Id,
         ciudad = Ciudad_Contacto_Nombre,
         diagnos = Codigo_Diagnostico_Op,
         categoria = Categoria_Dx_Id,
         quirur = Quirurgico,
         fecha_ingreso = Fecha_Ingreso_Hosp,
         dias_hosp = Numero_Dias_Hospitalario,
         dias_uci = Numero_Dias_Uci,
         dias_uce = Numero_Dias_Uce,
         proveedor = Proveedor,
         pago_hosp = Valor_Pagado_Diagnostico,
         rehosp_oms = rehosp_cat_oms) -> data_rehosp
head(data_rehosp)
```

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
# data_rehosp %>%
#   filter(rehosp_oms == 1) %>%
#   group_by(fecha_ingreso, ciudad) %>%
#   summarise(pago_hosp = sum(pago_hosp, na.rm = TRUE),
#             hosp = n()) %>%
#   plot_ly(data = .) %>%
#   add_trace(x = ~fecha_ingreso,
#             y = ~pago_hosp,
#             group = ~ciudad,
#             type = "scatter",
#             mode = "lines",
#             name = "Pago Hospitalización",
#             text = ~paste0("<b>Fecha Ingreso: </b>", fecha_ingreso, "<br><b>Pago Hospitalización: </b>", pago_hosp)) %>%
```


<ul>
<li>Variables continuas (4)
<ul>
<li>dias_hosp: Días de hospitalización</li>
<li>dias_uci: Número días en UCI</li>
<li>dias_uce: Número días en UCE</li>
<li>pago_hosp: Valor pagado primera hospitalización</li>
</ul>
</li>
</ul>
<ul>
<li>Variables nominales (5)
<ul>
<li>estrato: Estrato Vivienda (0,1,2,3,4,5,6,-1)</li>
<li>est_civil: Estado civil (C,D,S,U,V,-1)</li>
<li>ciudad: Ciudad de contacto del asegurado</li>
<li>diagnos: Código diagnóstico CIE10 de la primera atención </li>
<li>categoria: Categoría del diagnóstico según el tipo de enfermedad</li>
</ul>
</li>
</ul>
<ul>
<li>Variable dicotómica (4)
<ul>
<li>genero: Género del asegurado (M,F)</li>
<li>ramo: Ramo al que pertenece el asegurado</li>
<li>quirur: Si tuvo algun tipo de servicio relacionado a procedimiento quirúrgico</li>
<li>rehosp_cat_oms: Similitud categoría cie10. Esta es nuestra variable objetivo </li>
</ul>
</li>
</ul>
<ul>
<li>Variables discretas (2)
<ul>
<li>edad: Edad del asegurado en el momento de la hospitalización</li>
<li>marcas: Cantidad de marcas confirmadas del asegurado</li>
</ul>
</li>
</ul>
<ul>
<li>Variables ordinales (1)
<ul>
<li>ingreso: Rango de ingresos</li>
</ul>
</li>
</ul>
<ul>
<li>Fecha (1)
<ul>
<li>Fecha_Ingreso: fecha ingreso hospitalización </li>
</ul>
</li>
</ul>


<p style="text-align: justify;">Generamos la estadística descriptiva de los datos; en ella se puede visualizar que es necesario realizar más adelante algunas conversiones en los tipos de datos que vienen por defecto (por ejemplo el estrato aparece como una variable numérica). Pero antes de continuar con la codificación, procederemos a realizar un breve análisis de valores pérdidos que nos permitan refinar la limpieza requerida en los datos.</p>

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
skim_with(numeric = list(hist = NULL))

data_rehosp %>% 
  group_by() %>%
  skim()
```

A continuacion veremos algunas graficas que permiten realizar inferencias acerca del comportamiento de los datos
```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
require(scales)

data_rehosp %>%
  filter(pago_hosp > 0) %>%
  group_by(fecha_ingreso) %>%
  summarise_all(~sum(pago_hosp)) %>%
  ggplot(aes(x=fecha_ingreso, y=pago_hosp)) +
  geom_line() + geom_smooth(method = "lm") + theme_minimal() +
  labs(title = "Pago Hosp en el tiempo",
         x= "Fecha Ingreso",
         y = "Pago Hosp") +
    theme(plot.title = element_text(hjust = 0.5),
          legend.position = "none") + scale_y_continuous(labels = dollar) -> p30

p30 <- ggplotly(p30)
p30
```

```{r}
data_rehosp %>%
  group_by(ciudad) %>%
  summarise_all(~sum(rehosp_oms)) %>%
  filter(rehosp_oms > 8) %>%
    ggplot(
      aes(fill=ciudad,
          x=ciudad, 
          y=rehosp_oms)) +
    geom_bar(stat = "identity") + 
    theme_minimal() +
    labs(title = "Rehospitalizacion por ciudad",
         x= "Ciudad",
         y = "Cant. Rehosp") +
    theme(axis.text.x = element_text(angle = 90),
          plot.title = element_text(hjust = 0.5),
          legend.position = "none") +
    scale_fill_brewer(palette = "Blues")-> p31

p31 <- ggplotly(p31)
p31

```

```{r}
data_rehosp %>%
  group_by(diagnos) %>%
  summarise_all(~sum(rehosp_oms)) %>%
  filter(rehosp_oms > 3) %>%
    ggplot(
      aes(fill="none",
          x=diagnos, 
          y=rehosp_oms)) +
    geom_bar(stat = "identity") + 
    theme_minimal() +
    labs(title = "Rehospitalizacion por diagnostico",
         x= "Diagnostico",
         y = "Cant. Rehosp") +
    theme(axis.text.x = element_text(angle = 90),
          plot.title = element_text(hjust = 0.5),
          legend.position = "none") -> p32

p32 <- ggplotly(p32)
p32

```

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE, fig.width=8, fig.height=4}
# require(scales)
# 
# data_rehosp %>%
#   filter(rehosp_oms > 0) %>%
#   group_by(fecha_ingreso) %>%
#   summarise_all(~sum(rehosp_oms)) %>%
#   ggplot(aes(x=fecha_ingreso, y=rehosp_oms)) +
#   geom_line() + geom_smooth(method = "lm") + theme_minimal() +
#   labs(title = "Numero Rehosp en el Tiempo",
#          x= "Fecha Rehosp.",
#          y = "Num. Rehosp.") +
#     theme(plot.title = element_text(hjust = 0.5),
#           legend.position = "none") -> p34
# 
# p34 <- ggplotly(p34)
# p34
```


<a href="#Inicio">Volver al inicio</a></li>


<h2 style="text-align: center;"><a id="Perdidos">Análisis de Registros Pérdidos</a></h2>

<p style="text-align: justify;">En la gráfica siguiente podemos observar que hay en total 3 variables que no contienen registros vacios: estrato, estado civil e ingreso.</p>

<p style="text-align: justify;">A nivel individual el porcentaje de valores perdidos para todos los casos es superior al 25%. De forma combinada hay 318 registros vacíos en ingreso, 259 en sólo el estrato y 144 en el estado civil, el resto  de los campos nulos corresponde a combinaciones entre dos variables; por ende no podemos decir que la probabilidad de que falte un valor depende solo del valor observado, y usar un método para imputarlo (la forma no es aleatoria).</p>

```{r, message = FALSE, warning = FALSE, eval =TRUE, echo = FALSE}
aggr(data_rehosp, 
     combined = FALSE, 
     prop = c(TRUE, TRUE),
     col = c("#CCE5FF", "#0066CC"),
     cex.axis = 0.7,
     gap = 1.5,
     border = NA,
     bars = FALSE,
     ylab = c("Proporción de Datos Perdidos", "Combinaciones"))
```

<p style="text-align: justify;">Para corroborar que los datos no faltan al azar, se realiza un grafico de correlación que nos ayude a verificar lo anterior. Para ello, construimos un dataframe que indique si el campo está vacio (1) o no (0); con esta información seleccionamos sólo aquellas columnas que tienen algunos (no todos) sus registros nulos y finalmente creamos la matrix de correlación.</p>

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
matrix_miss <- as.data.frame(abs(is.na(data_rehosp)))
only_miss <- matrix_miss[,sapply(matrix_miss, sd) > 0]
corr_miss <- round(cor(only_miss),3)
p.mat <- cor_pmat(only_miss)

ggcorrplot(corr_miss, 
           type = "lower",
           outline.col = "white",
           p.mat = p.mat,
           sig.level = 0.05,
           ggtheme = ggplot2::theme_minimal,
           lab = TRUE,
           colors = c("#99CCFF", "white", "#0066CC")) + 
  labs(title = "Correlacion entre datos perdidos por columna")
```

<p style="text-align: justify;">Dado que con la anterior matrix a un nivel de significancia del 5% se comprueba la hipótesis inicial de no aleatoriedad, se procede a construir una tercera categoría para cada una de las variables que posee campos vacíos.</p>

<p style="text-align: justify;">Para estimar si existe una asociación entre las variables que pueda derivarse en colinealidad, se procede primero a verificar que las variables no poseen una distribución normal, una vez realizado esto, se elige el test de Spearman para hallar la correlación lineal por atributo.</p>

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
data_rehosp %>%
  select(pago_hosp, 
         dias_uci,
         dias_uce,
         dias_hosp,
         rehosp_oms) -> data_num

norm_test <- lapply(data_num, lillie.test)
lres <- sapply(norm_test, `[`, c("statistic","p.value"))
t(lres)
```

<p style="text-align: justify;">Los resultados confirman que ninguna de las variables pesenta una distribución normal y las correlaciones relacionadas a continuación, verifican posibles asociaciones entre las variables de los días en que el paciente estuvo internado en la Unidad de Cuidados Intensivos, en la Unidad de Cuidados Especiales y los días que el paciente estuvo hospitalizado. Por conocimiento de facto, la relación entre la variable "dias_uci" y "dias_uce" es entendible, ya que cuando un paciente que ha pasado por la Unidad de Cuidados Intensivos pasó su momento de crisis y su estado de salud es más estable, suele ser remitido a la Unidad de Cuidados Especiales. </p>

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
corr_num <- round(cor(data_num),4)
p.mat <- cor_pmat(data_num, method = "spearman")

ggcorrplot(corr_num, 
           type = "lower",
           outline.col = "white",
           p.mat = p.mat,
           sig.level = 0.05,
           ggtheme = ggplot2::theme_minimal,
           lab = TRUE,
           colors = c("#99CCFF", "white", "#0066CC")) + 
  labs(title = "Correlacion entre variables numéricas")
```

<p style="text-align: justify;">Las correlaciones obtenidas no cumplen un umbral suficiente para considerarlas importantes, por ende se procede a conservarlas y evaluar más adelante si es preciso eliminarlas definitivamente al construir un modelo con fines predictivos. Por otro lado, la variable categoría y diagnóstico están altamente correlacionadas con la variable endógena, por lo que es necesario eliminarlas del análisis, para no incurrir en posibles sobreajustes en la etapa de modelado.</p>

<p style="text-align: justify;">Teniendo en cuenta el análisis de datos perdidos o nulos, se decide descartar la variable ingreso ya que contiene mas de un 30% en datos perdidos.</p>

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}

data_rehosp %>%
  mutate(estrato = ifelse(is.na(estrato) | estrato == -1 | estrato == 0, "Sin Informacion", estrato),
         est_civil = ifelse(is.na(est_civil), "Sin Informacion", est_civil),
         ingreso = ifelse(is.na(ingreso), "Sin Informacion", ingreso),
         proveedor = ifelse(is.na(proveedor), "Sin Informacion", proveedor),
         quirur = ifelse(quirur == 1, 'Si', 'No'),
         edad = case_when( edad <= 30 ~ "18-30",
                           edad >= 31 & edad <= 40 ~ "31-40",
                           edad >= 41 & edad <= 50 ~ "41-50",
                           edad >= 51 & edad <= 60 ~ "51-60",
                           edad >= 61 & edad <= 70 ~ "61-70",
                           edad >= 71 & edad <= 80 ~ "71-80",
                           edad >= 81 ~ "81+"),
         marcas = cut(marcas, breaks = (0:3)*2, include.lowest = TRUE),
         est_civil = as.factor(est_civil),
         genero = as.factor(genero),
         ciudad = as.factor(ciudad),
         quirur = as.factor(quirur),
         proveedor = as.factor(proveedor),
         ramo = as.factor(ramo),
         edad = as.factor(edad),
         estrato = as.factor(estrato)) %>%
  select(-diagnos, -categoria, -fecha_ingreso, -ingreso) -> data_rehosp

str(data_rehosp)
```

<a href="#Inicio">Volver al inicio</a></li>

<h2 style="text-align: center;"><a id="Analisis">Análisis Exploratorio</a></h2>

<h3 style="text-align: center;"><a id="AnalisisCon">Análisis univariado - variables continuas</a></h3>

<p style="text-align: justify;">Es evidente la existencia también, de valores atípicos muy marcados tanto en el numéro de días de hospitalización, como en los números de días que el paciente estuvo en la Unidad de Cuidado Intensivo y Especial, en dónde los valores atípicos más grandes suceden en los eventos que terminaron en rehospitalización.</p>

<p style="text-align: justify;">Con el análisis anterior no sólo se logra identificar variables con presencia de valores atípicos, sino que también es posible evidenciar que los datos se encuentran altamente desbalanceados. Por ende, antes de continur con la exploración de los datos se procede a tratar ambos problemas. En el caso de los outliers se truncará en los casos en que sea necesario, imputando los valores que superen cierto límite en el percntil, tanto mayor como menor.</p>

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
data_rehosp %>%
  mutate(pago_hosp = ifelse(quirur == "Si" & rehosp_oms == 0, 
                            outlier(mydata = filter(data_rehosp, quirur == "Si" & rehosp_oms == 0), 
                                    value = "pago_hosp", q_min = 0, q_max = 0.97), pago_hosp),
         pago_hosp = ifelse(quirur == "Si" & rehosp_oms == 1, 
                            outlier(mydata = filter(data_rehosp, quirur == "Si" & rehosp_oms == 1),
                                    value = "pago_hosp", q_min = 0, q_max = 0.98), pago_hosp),
         pago_hosp = ifelse(quirur == "No" & rehosp_oms == 0, 
                            outlier(mydata = filter(data_rehosp, quirur == "No" & rehosp_oms == 0),                                                      value = "pago_hosp", q_min = 0, q_max = 0.97), pago_hosp), 
         pago_hosp = ifelse(quirur == "No" & rehosp_oms == 1, 
                            outlier(mydata = filter(data_rehosp, quirur == "No" & rehosp_oms == 1), 
                                    value = "pago_hosp", q_min = 0, q_max = 0.98), pago_hosp),
         dias_hosp = ifelse(rehosp_oms == 0, 
                            outlier(mydata = filter(data_rehosp, rehosp_oms == 0), 
                                                    value = "dias_hosp", q_min = 0, q_max = 0.99),
                            outlier(mydata = filter(data_rehosp, rehosp_oms == 1), 
                                                    value = "dias_hosp", q_min = 0, q_max = 0.99)),
         dias_uci = ifelse(rehosp_oms == 0, 
                           outlier(mydata = filter(data_rehosp, rehosp_oms == 0 & dias_uci > 0), 
                                                    value = "dias_uci", q_min = 0, q_max = 0.99)
                           , dias_uci),
         dias_uce = ifelse(rehosp_oms == 0, 
                           outlier(mydata = filter(data_rehosp, rehosp_oms == 0 & dias_uce > 0), 
                                                    value = "dias_uce", q_min = 0, q_max = 0.99)
                           , dias_uci)) -> data_rehosp
```


<p style="text-align: justify;">Se puede observar que tanto en el numéro de marcas como en la variable de pago, correspondiente al primer diagnóstico, no parece haber una diferencia significativa en la distribución al discriminar por la variable objetivo binaria, es decir, entre los casos de rehospitalización (1) y casos de no rehospitalización (0). Adicionalmente, la distibución en ambas variables no es simétrica. En el caso de las marcas se observa una asimetría positiva o sesgada a la derecha y de manera similar, aunque menos marcada, para el caso del pago en el primer diagnóstico.</p>

<p style="text-align: justify;">Los datos se encuentran bastante dispersos y reflejan presencia de outliers.</p>

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}

p5 <- myboxplot(mydata = filter(data_rehosp, pago_hosp > 0), 
                myexposure = "rehosp_oms", 
                myoutcome = "pago_hosp", 
                mytitle = "Pago hospitalización", 
                mylabel_x = "", 
                mylabel_y = "Pago Diag", 
                my_fill = "")

p6 <- myboxplot(mydata = data_rehosp, 
                myexposure = "rehosp_oms", 
                myoutcome = "dias_hosp", 
                mytitle = "Total dias hospitalizado", 
                mylabel_x = "", 
                mylabel_y = "Dias hospitalización", 
                my_fill = "")

p7 <- myboxplot(mydata = filter(data_rehosp, dias_uci > 0), 
                myexposure = "rehosp_oms", 
                myoutcome = "dias_uci", 
                mytitle =  "Total días UCI", 
                mylabel_x = "", 
                mylabel_y = "Dias UCI", 
                my_fill = "")

p8 <- myboxplot(mydata = filter(data_rehosp, dias_uce > 0), 
                myexposure = "rehosp_oms", 
                myoutcome = "dias_uce", 
                mytitle = "Total días UCE", 
                mylabel_x = "", 
                mylabel_y = "Dias UCE", 
                my_fill = "")

p5 <- ggplotly(p5)
p6 <- ggplotly(p6)
p7 <- ggplotly(p7)
p8 <- ggplotly(p8)

subplot(p7, p8, p5, p6, nrows = 2, ncol(2))



```

<h3 style="text-align: center;"><a id="AnalisisCar">Análisis univariado - variables cardinales</a></h3>

<p style="text-align: justify;">Observando las variables categóricas la diferencia entre la probabilidad de que el evento ocurra (haya rehospitalización) o no, se puede evidenciar sólo en algunas clases por categoría, pero en general, las proporciones suelen ser bastantes similares, por lo que no es posible elaborar a priori una hipótesis que estipule diferencias significativas en las distribuciones, por lo menos para ninguna de las dos variables relacionadas en el gráfico a continuación.</p>

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}

p9 <- mygeom_bar(mydata = data_rehosp, 
                 myexposure = "edad", 
                 myoutcome = "rehosp_oms", 
                 mytitle = "Edad", 
                 mylabel_x = "", 
                 mylabel_y = "Frecuencia", 
                 my_fill = "Rehospitalización", 
                 my_angle = NULL,
                 my_legend = "right")

p10 <- mygeom_bar(mydata = data_rehosp, 
                  myexposure = "estrato", 
                  myoutcome = "rehosp_oms", 
                  mytitle = "Estrato", 
                  mylabel_x = "", 
                  mylabel_y = "Frecuencia", 
                  my_fill = "Rehospitalización", 
                  my_angle = NULL,
                  my_legend = "none")

grid.arrange(p9,
             p10)

#p9 <- ggplotly(p9)
#p10 <- ggplotly(p10)

#subplot(p9, p10, nrows = 2)


```

<p style="text-align: justify;">Por otro lado, el atributo que indica el hecho de que se hayan realizado procedimientos quirúrgicos durante la primera hospitalización muestran cierta diferencia en la distribuión por grupo; es más probable que la persona deba ser rehospitalizada de nuevo.</p>

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}

p14 <- mygeom_bar(mydata = data_rehosp, 
                  myexposure = "quirur", 
                  myoutcome = "rehosp_oms", 
                  mytitle = "Proc quirúrgico", 
                  mylabel_x = "", 
                  mylabel_y = "Frecuencia", 
                  my_fill = "Rehospitalización", 
                  my_angle = NULL,
                  my_legend = "bottom")

p17 <- mygeom_bar(mydata = data_rehosp, 
                  myexposure = "marcas", 
                  myoutcome = "rehosp_oms", 
                  mytitle = "Marcas", 
                  mylabel_x = "", 
                  mylabel_y = "Frecuencia", 
                  my_fill = "Rehospitalización", 
                  my_angle = NULL,
                  my_legend = "bottom")

grid.arrange(p14,
              p17,
              ncol = 1,
              nrow = 2)

#p14 <- ggplotly(p14)
#p17 <- ggplotly(p17)

#subplot(p14, p17, ncol(1), nrows = 2)


```

```{r, warning = FALSE, message = FALSE, echo = FALSE, eval = FALSE}

p15 <- mygeom_bar(mydata = data_rehosp, 
                  myexposure = "ramo", 
                  myoutcome = "rehosp_oms", 
                  mytitle = "Ramo Seguro", 
                  mylabel_x = "", 
                  mylabel_y = "Frecuencia", 
                  my_fill = "Rehospitalización", 
                  my_angle = NULL,
                  my_legend = "none")

p16 <- mygeom_bar(mydata = data_rehosp, 
                  myexposure = "est_civil", 
                  myoutcome = "rehosp_oms", 
                  mytitle = "Estado civil", 
                  mylabel_x = "", 
                  mylabel_y = "Frecuencia", 
                  my_fill = "Rehospitalización", 
                  my_angle = NULL,
                  my_legend = "right")


p11 <- mygeom_bar(mydata = data_rehosp, 
                  myexposure = "genero", 
                  myoutcome = "rehosp_oms", 
                  mytitle = "Género", 
                  mylabel_x = "", 
                  mylabel_y = "Frecuencia", 
                  my_fill = "Rehospitalización", 
                  my_angle = NULL,
                  my_legend = "none")

grid.arrange(p15,
             p11,
             p16,
            ncol = 2,
            nrow = 2,
            layout_matrix = rbind(c(1,2), c(3,3)))

```

<p style="text-align: justify;">Con el objetivo de enriquecer el análisis exploratorio, se calcularán dos medidas muy comúnes de la teoría de la información, éstas permiten inferir algo del poder predictivo que pueden tener las variables independientes, antes de hacer parte de un modelo.</p>

<a href="#Inicio">Volver al inicio</a></li>

<h2 style="text-align: center;"><a id="AnalisisWOE">Análisis de clasificación binaria usando WOE y el IV</a></h2>

<p style="text-align: justify;">El peso de la evidencia (WOE) y el valor de la información (IV) ayudan, entre otras cosas, a determinar la contribución independiente de cada variable al resultado, y detectar relaciones lineales y no lineales. El WOE mide la relación entre la variable predictiva y el objeto binario, mientras que el IV mide la fuerza predictiva de esa relación.</p>

<p style="text-align: justify;">La tabla a continuación contiene los valores del "valor de la información" con y sin el ajuste derivado de la validación cruzada. Cuando se realiza el ajuste con el objetivo de que los re

sultados sean más estables, sólo el pago del diagnóstico, si el paciente pasó por la Unidad de cuidados Especiales la primera vez y si fueron realizados procedimientos quirúrgicos serán las únicas variables con suficiente capacidad de predicción a nivel individual y univariable (Iv > 5%). Cuando se relaja el supuesto, IV sin restar el penalty, se incluirían las marcas y la edad y la ciudad.</p>

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
set.seed(1234)
data_rehosp <- data_rehosp %>%
  mutate(id = 1:nrow(.)) 

data_rehosp %>%
  sample_frac(size = .70) -> train

data_rehosp %>%
  anti_join(x = .,
            y = train, 
            by = "id") -> test
  
train <- select(.data = train, -id)
test <- select(.data = test, -id)

IV <- create_infotables(data = train,
                   valid = test,
                   y = "rehosp_oms")

kable_styling(kable(IV$Summary), 
              position = "center", 
              row_label_position = 1,
              full_width = F)
```

<p style="text-align: justify;">De acuerdo al poder predictivo de cada una de las variables, se eligen aquellas cuyo Valor de la informaciÓn (IV) sea superior al 2% (0,02). Las variables con IV inferiores a este valor se consideran impredictivas y se decide descartarlas. Las variables que continuan, en orden de relevancia segun su poder predictor, son:</p>

<ul>
<li>pago_hosp</li>
<li>quirur</li>
<li>dias_uce</li>
<li>dias_uci</li>
<li>proveedor</li>
<li>dias_hosp</li>
<li>estrato</li>
<li>ciudad</li>
</ul>

<p style="text-align: justify;">Enfocandonos en el pago del diagnóstico, el cual, es la variable con mayor influencia, el WOE nos indica una relación no lineal, con un incremento en el WOE a medida que disminuye el rango de pago en el diagnóstico.</p>

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
kable_styling(kable(IV$Tables$edad), 
              position = "center", 
              row_label_position = 1,
              full_width = F)
```

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
n <- names(IV$Tables)
for (i in 1:length(n)){
   plot_infotables(IV, n[i])}

MultiPlot(IV, IV$Summary$Variable[1:9])
```

<p style="text-align: justify;">Como se pudo observar en el analisis del WOE, esta técnica ajusta los valores de las variables numericas en rangos acotados de acuerdo al valor de la informacion de cada una de ellas en relacion con la variable dependiente. Por esto, es importante transformar dichas variables en los rangos recomendados.</p>

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
# data_rehosp %>%
#   mutate(pago_hosp1 = case_when( pago_hosp <= 107410 ~ "[0,107410]",
#                            pago_hosp >= 107570 & pago_hosp <= 776965 ~ "[107570,776965]",
#                            pago_hosp >= 777697 & pago_hosp <= 1547806 ~ "[777697,1547806]",
#                            pago_hosp >= 1547847 & pago_hosp <= 2251764 ~ "[1547847,2251764]",
#                            pago_hosp >= 2251913 & pago_hosp <= 3021862 ~ "[2251913,3021862]",
#                            pago_hosp >= 3022030 & pago_hosp <= 3996928 ~ "[3022030,3996928]",
#                            pago_hosp >= 3996933 & pago_hosp <= 5328423 ~ "[3996933,5328423]",
#                            pago_hosp >= 5329500 & pago_hosp <= 7048290 ~ "[5329500,7048290]",
#                            pago_hosp >= 7048902 & pago_hosp <= 11408415 ~ "[7048902,11408415]",
#                            pago_hosp >= 11408625 & pago_hosp <= 47387883 ~ "[11408625,47387883]",
#                            pago_hosp >= 47387883 ~ "[47387883+"),
#          dias_hosp1 = case_when( dias_hosp = 1 ~ "[1]",
#                                 dias_hosp = 2 ~ "[2]",
#                                 dias_hosp = 3 ~ "[3]",
#                                 dias_hosp = 4 ~ "[4]",
#                                 dias_hosp >= 5 & dias_hosp <= 7 ~ "[5,7]",
#                                 dias_hosp >= 8 & dias_hosp <= 30 ~ "[8,30]")) -> data_rehosp2
# 
# 
# str(data_rehosp)

```

<a href="#Inicio">Volver al inicio</a></li>

<h2 style="text-align: center;"><a id="Modelo">Modelo</a></h2>

<p style = "text-align: justify;">El objetivo principal del análisis es estimar un modelo predictivo con el cuál se pueda analizar la probabilidad de que un paciente termine en una rehospitalización asociada a un diangóstico anterior. Para ello se empleará un modelo de regresión logística, el cuál es ampliamente utilizado cuando se enfrenta a problemas de clasificación binaria.</p>

<p style = "text-align: justify;">Una vez se realizan los filtros de calidad y completitud, y tras lo obtenido en los resultados del WOE, se procede a realizar la seleccion de variables para el modelo. Se tendrán en cuenta entonces, el pago realizado, los días en que estuvo el paciente en la Unidad de Cuidados, el hecho de que se le haya realizado o no una cirugía y el estrato.</p>

<p style = "text-align: justify;">Para evaluar la capacidad de generalización del modelo, se dividirá el conjunto de datos en entrenamiento (70%) y prueba (30%).</p>

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
set.seed(1234)
data_rehosp %>%
  select(id,
        pago_hosp,
        quirur,
        dias_uce,
        dias_uci,
        dias_hosp,
        estrato,
        rehosp_oms) -> data_rehosp

data_rehosp %>%
  sample_frac(size = 0.7) -> training

data_rehosp %>%
  anti_join(x = .,
            y = training,
            by = "id") -> testing

testing %>%
  select(-id) -> testing

training %>%
  select(-id) %>%
  mutate(rehosp_oms = as.factor(rehosp_oms)) -> training

```

<h3 style="text-align: center;"><a id="SMOTE">Smote</a></h3>

<p style="text-align: justify;">Como se habia mencionado anteriormente, la informacion se encuentra desbalanceada; esto es, teniendo en cuenta que el problema en que se esta trabajando consiste en la clasificacion de una variable dicotómica, se debe analizar el nivel de representacion de sus posibles valores dentro del conjunto total de datos.</p>

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}

kable(as.data.frame(prop.table(table(data_rehosp$rehosp_oms)))) %>%
kable_styling(position = "center", 
              row_label_position = 1,
              full_width = F) %>%
row_spec(0,background="#EBF0F7")


```

<p style="text-align: justify;">Vemos que la representacion para la categoría positiva es un poco mas del 2% de la información. En este caso vamos a realizar un tratamiento que permita aumentar la clase minoritaria, sin utilizar soluciones genéricas como reducir la clase mayoritaria al nivel de la clase minoritaria.</p>

<p style="text-align: justify;">Para este caso vamos a utilizar la técnica SMOTE (Synthetic Minority Oversampling Method), la cual genera nuevas instancias artificiales de la clase minoritaria interpolando los valores de las instancias minoritarias más cercanas a una dada.</p>

<p style="text-align: justify;">Por medio de SMOTE se generará un nuevo set de datos de entrenamiento, en el cual se tenga un 60% de informacion para la categoria negativa (rehosp_oms = 0) y 40% para la categoria positiva (rehosp_oms = 0).</p>

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}
training <- SMOTE(rehosp_oms ~ ., as.data.frame(training), perc.over = 300, perc.under = 200)
```

Verificamos que el set de entrenamiento se encuentre balanceado:

```{r, message = FALSE, warning = FALSE, echo = FALSE, eval =TRUE}

kable_styling(kable(as.data.frame(prop.table(table(training$rehosp_oms)))), 
              position = "center", 
              row_label_position = 1,
              full_width = F) %>%
row_spec(0,background="#EBF0F7")

```

<h3 style="text-align: center;"><a id="Analisis">Ajuste del modelo y Estimación de parámetros</a></h3>

Del resultado exploratorio anterior, al discriminar el análisis de las variables independientes por nuestra variable objetivo (Rehospitalización), es posible evidenciar una diferencia clara entre las distribuciones para los atributos: Pago/costo del procedimiento y los días en que el usuario estuvo internado ya sea en la Unidad de Cuidados Intensivos o Especiales. Esto podría ser un indicio de que estas variables en particular, podrían a llegar a ser relevantes para explicar la probabilidad de ocurrencia del evento, cuando hubo una hospitalización anterior ligada a ese diagnóstico.

A continuación, al ajustar el modelo obtenemos los siguientes resultados:

```{r, message = FALSE, echo = FALSE, eval =TRUE}
mylogit <- glm(rehosp_oms ~ pago_hosp + quirur +  dias_hosp + dias_uce + dias_uci + estrato, data = training, family = "binomial")
summary(mylogit)
```

1. Cada cambio en una unidad en el pago hospitalario disminuirá las probabilidades de rehospitalización, pero en una cantidad muy pequeña (-7.308E-08)
2. Cuando a un paciente se le realiza un procedimiento quirúrgico su probabilidad de que termine hospitalizado de nuevo por el mismo dianóstico, disminuye en 0.14 en comparación a cuando no se le realiza ninguna cirugía.
3. La probabilidad de rehospitalización decrece, al permanecer un día adicional el paciente en la UCE (en 1.45) y la UCI (1.73)

El resto de las variables no son suficientemente explicativas para predecir, de manera significativa, su efecto sobre la variable de respuesta binaria.

<h3 style="text-align: center;"><a id="Evaluación">Prediciendo y evaluando el desempeño del modelo</a></h3>

Después de estimados los coeficentes procedemos a realizar la predicción dentro y fuera de muestra para evaluar la precisión (accuracy) de nuestro modelo. Los resultados 
```{r, message = FALSE, echo = FALSE, eval =TRUE}
pred_train <- predict(mylogit, newdata = training[-7], type = "response")
y_pred_train <- ifelse(pred_train > 0.5, 1, 0)
y_act_train <- training$rehosp_oms

pred = predict(mylogit, type = 'response', newdata = testing[-7])
y_pred = ifelse(pred > 0.5, 1, 0)
y_act <- testing$rehosp_oms


kable(data.frame(Train = mean(y_pred_train == y_act_train), Test = mean(y_pred == y_act))) %>%
  kable_styling(position = "center", 
                row_label_position = 1,
                full_width = F) %>%
row_spec(0,background="#EBF0F7")
  
```

```{r}

```


```{r, message = FALSE, echo = FALSE, eval =TRUE}
library(ROCR)
ROCRpred = prediction(pred, testing$rehosp_oms)
 
# Performance function
ROCRperf = performance(ROCRpred, "tpr", "fpr")

perf1 <- performance(ROCRpred, "prec", "rec")
plot(perf1)
 
# Plot ROC curve
plot(ROCRperf)
# Add colors
plot(ROCRperf, colorize=TRUE)
# Add threshold labels 
plot(ROCRperf, colorize=TRUE, print.cutoffs.at=seq(0,1,by=0.1), text.adj=c(-0.2,1.7))


cm = table(as.matrix(testing[, 7]), y_pred > 0.5)
cm
```

